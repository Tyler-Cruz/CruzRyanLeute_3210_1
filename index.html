<!DOCTYPE html>
<html>
<head>
    <title>CruzRyanLeute Puzzle</title>
</head>
<body>

    <canvas id="myCanvas" width="1200" height="800"></canvas>

    <script type="module">
import * as THREE from 'three';
import { DragControls } from 'three/examples/jsm/controls/DragControls.js';

//random positions
function getRandom(min, max){
  return Math.random() * (max - min) + min;
}

//creates a canvas in the shape of an octagon
function Canvas(a, aCol, b, bCol, c, cCol, d, dCol, e, eCol, f, fCol, g, gCol, h, hCol, i, iCol, j, jCol, k, kCol, l, lCol, m, mCol, n, nCol, o, oCol, p, pCol){
    //makes triangles to form the shape of an octagon
    this.tri1 = new Triangle(a, aCol, d, dCol, e, eCol);
    this.tri2 = new Triangle(a, aCol, e, eCol, b, bCol);
    this.tri3 = new Triangle(b, bCol, e, eCol, f, fCol);
    this.tri4 = new Triangle(b, bCol, f, fCol, c, cCol);
    this.tri5 = new Triangle(c, cCol, f, fCol, g, gCol);
    this.tri6 = new Triangle(c, cCol, g, gCol, h, hCol);
    this.tri7 = new Triangle(d, dCol, i, iCol, e, eCol);
    this.tri8 = new Triangle(e, eCol, i, iCol, j, jCol);
    this.tri9 = new Triangle(e, eCol, j, jCol, f, fCol);
    this.tri10 = new Triangle(f, fCol, j, jCol, k, kCol);
    this.tri11 = new Triangle(f, fCol, k, kCol, g, gCol);
    this.tri12 = new Triangle(g, gCol, k, kCol, l, lCol);
    this.tri13 = new Triangle(g, gCol, l, lCol, h, hCol);
    this.tri14 = new Triangle(h, hCol, l, lCol, m, mCol);
    this.tri15 = new Triangle(i, iCol, n, nCol, j, jCol);
    this.tri16 = new Triangle(j, jCol, n, nCol, k, kCol);
    this.tri17 = new Triangle(k, kCol, n, nCol, o, oCol);
    this.tri18 = new Triangle(k, kCol, o, oCol, l, lCol);
    this.tri19 = new Triangle(l, lCol, o, oCol, p, pCol);
    this.tri20 = new Triangle(l, lCol, p, pCol, m, mCol);
    


    this.render = function(){
        this.tri1.render();
        this.tri2.render();
        this.tri3.render();
        this.tri4.render();
        this.tri5.render();
        this.tri6.render();
        this.tri7.render();
        this.tri8.render();
        this.tri9.render();
        this.tri10.render();
        this.tri11.render();
        this.tri12.render();
        this.tri13.render();
        this.tri14.render();
        this.tri15.render();
        this.tri16.render();
        this.tri17.render();
        this.tri18.render();
        this.tri19.render();
        this.tri20.render();

    }
}

//creates a canvas in the shape of an octagon
function Canvas2(a, aCol, b, bCol, c, cCol, d, dCol, e, eCol, f, fCol, g, gCol, h, hCol, i, iCol, j, jCol, k, kCol, l, lCol, m, mCol, n, nCol, o, oCol, p, pCol){
    //makes triangles to form the shape of an octagon
    this.tri1 = new pieceTriangle(a, aCol, d, dCol, e, eCol);
    this.tri2 = new pieceTriangle(a, aCol, e, eCol, b, bCol);
    this.tri3 = new pieceTriangle(b, bCol, e, eCol, f, fCol);
    this.tri4 = new pieceTriangle(b, bCol, f, fCol, c, cCol);
    this.tri5 = new pieceTriangle(c, cCol, f, fCol, g, gCol);
    this.tri6 = new pieceTriangle(c, cCol, g, gCol, h, hCol);
    this.tri7 = new pieceTriangle(d, dCol, i, iCol, e, eCol);
    this.tri8 = new pieceTriangle(e, eCol, i, iCol, j, jCol);
    this.tri9 = new pieceTriangle(e, eCol, j, jCol, f, fCol);
    this.tri10 = new pieceTriangle(f, fCol, j, jCol, k, kCol);
    this.tri11 = new pieceTriangle(f, fCol, k, kCol, g, gCol);
    this.tri12 = new pieceTriangle(g, gCol, k, kCol, l, lCol);
    this.tri13 = new pieceTriangle(g, gCol, l, lCol, h, hCol);
    this.tri14 = new pieceTriangle(h, hCol, l, lCol, m, mCol);
    this.tri15 = new pieceTriangle(i, iCol, n, nCol, j, jCol);
    this.tri16 = new pieceTriangle(j, jCol, n, nCol, k, kCol);
    this.tri17 = new pieceTriangle(k, kCol, n, nCol, o, oCol);
    this.tri18 = new pieceTriangle(k, kCol, o, oCol, l, lCol);
    this.tri19 = new pieceTriangle(l, lCol, o, oCol, p, pCol);
    this.tri20 = new pieceTriangle(l, lCol, p, pCol, m, mCol);
    


    this.render = function(){
        this.tri1.render();
        this.tri2.render();
        this.tri3.render();
        this.tri4.render();
        this.tri5.render();
        this.tri6.render();
        this.tri7.render();
        this.tri8.render();
        this.tri9.render();
        this.tri10.render();
        this.tri11.render();
        this.tri12.render();
        this.tri13.render();
        this.tri14.render();
        this.tri15.render();
        this.tri16.render();
        this.tri17.render();
        this.tri18.render();
        this.tri19.render();
        this.tri20.render();

    }
}

//distance for snap


// Create the object to represent a triangle
function Triangle (a, aCol, b, bCol, c, cCol) {
    // Build the vertices and colors manually by creating arrays
    this.vertices = [
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ];
    this.colors = [
      aCol[0], aCol[1], aCol[2],
      bCol[0], bCol[1], bCol[2],
      cCol[0], cCol[1], cCol[2]
    ];

  // The function that actually adds the triangle geometry to the scene
  this.render = function() {
    var geometry = new THREE.BufferGeometry();
    // Set the "position" attribute accordingly
    // Note: itemSize = 3 (second argument) because there are 3 values (components) per vertex
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3 ) );
    geometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array(this.colors), 3 ) );
    // Indicate that the material's vertexColors are based on the color attribute of vertexes
    var material = new THREE.MeshBasicMaterial( { vertexColors: true } );
    this.mesh= new THREE.Mesh( geometry, material );
    scene.add(this.mesh);

  }	
}

// specific triangle function definition so that only puzzle pieces can be dragged
function pieceTriangle (a, aCol, b, bCol, c, cCol) {
    // Build the vertices and colors manually by creating arrays
    this.vertices = [
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ];
    this.colors = [
      aCol[0], aCol[1], aCol[2],
      bCol[0], bCol[1], bCol[2],
      cCol[0], cCol[1], cCol[2]
    ];

  // The function that actually adds the triangle geometry to the scene
  this.render = function() {
    var geometry = new THREE.BufferGeometry();
    // Set the "position" attribute accordingly
    // Note: itemSize = 3 (second argument) because there are 3 values (components) per vertex
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3 ) );
    geometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array(this.colors), 3 ) );
    // Indicate that the material's vertexColors are based on the color attribute of vertexes
    var material = new THREE.MeshBasicMaterial( { vertexColors: true } );
    this.mesh= new THREE.Mesh( geometry, material );
    scene.add(this.mesh);

    //add mesh to drag list
    draggableObjects.push(this.mesh);

  }	
}



var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 3;  // Try moving this around!
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);

// Array for objects to drag
var draggableObjects = [];

//creates a red octagon to be the canvas of the puzzle
var octagon = new Canvas([-.25,.5,0],[1,0,0],[0,.5,0],[1,0,0],[.25,.5,0],[1,0,0],[-.5,.25,0],[1,0,0],[-.25,.25,0],[1,0,0],
[0,.25,0],[1,0,0],[.25,.25,0],[1,0,0],[.5,.25,0],[1,0,0],[-.5,-.25,0],[1,0,0],[-.25,-.25,0],[1,0,0],
[0,-.25,0],[1,0,0],[.25,-.25,0],[1,0,0],[.5,-.25,0],[1,0,0],[-.25,-.5,0],[1,0,0],[0,-.5,0],[1,0,0],
[.25,-.5,0],[1,0,0]);

var octagon2 = new Canvas2([-.25,.5,0],[1,0,1],[0,.5,0],[1,1,0],[.25,.5,0],[0,1,0],[-.5,.25,0],[0,0,1],[-.25,.25,0],[0,1,1],
[0,.25,0],[0,1,0],[.25,.25,0],[1,1,1],[.5,.25,0],[1,0,1],[-.5,-.25,0],[0,1,0],[-.25,-.25,0],[0,0,0],
[0,-.25,0],[1,1,1],[.25,-.25,0],[0,1,0],[.5,-.25,0],[1,1,0],[-.25,-.5,0],[0,1,0],[0,-.5,0],[0,0,1],
[.25,-.5,0],[0,1,0]);

octagon.render();
octagon2.render();


//Drag setup
var controls = new DragControls(draggableObjects, camera, renderer.domElement);

// event listeners for drag control events
controls.addEventListener('dragstart', function (event) {
    event.object.material.opacity = 0.5;
});

controls.addEventListener('dragend', function (event) {
    event.object.material.opacity = 1; 
});

//Something New: Audio
//loads the downloaded song in from the files
let bMusic = new Audio('elevator-music-kevin-macleod-background-music-hd-128-ytshorts.savetube.me.mp3');
//autoplays the sound from the background
bMusic.play();

// Essentially, this creates the "Frames-per-second" loop
function animate() {
  requestAnimationFrame( animate );
  render();
}

// This is a wrapper function (needed for the requestAnimationFrame call above) for render
function render(){
  renderer.render( scene, camera );
}

// Initiate the graphical loop
animate();
var globalTranslateToggle = 0.3;

document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>