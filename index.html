<!DOCTYPE html>
<html>
<head>
    <title>CruzRyanLeute Puzzle</title>
</head>
<body>

    <canvas id="myCanvas" width="1200" height="800"></canvas>

    <script type="module">
import * as THREE from 'three';

//random positions
function getRandom(min, max){
  return Math.random() * (max - min) + min;
}

//creates a canvas in the shape of an octagon
function Canvas(a, aCol, b, bCol, c, cCol, d, dCol, e, eCol, f, fCol, g, gCol, h, hCol){
    //makes triangles to form the shape of an octagon
    this.tri1 = new Triangle(a, aCol, c, cCol, b, bCol);
    this.tri2 = new Triangle(a, aCol, d, dCol, c, cCol);
    this.tri3 = new Triangle(a, aCol, e, eCol, d, dCol);
    this.tri4 = new Triangle(a, aCol, f, fCol, e, eCol);
    this.tri5 = new Triangle(a, aCol, g, gCol, f, fCol);
    this.tri6 = new Triangle(a, aCol, h, hCol, g, gCol);

    this.render = function(){
        this.tri1.render();
        this.tri2.render();
        this.tri3.render();
        this.tri4.render();
        this.tri5.render();
        this.tri6.render();

    }
}

// An object to produce a Square
function Square( a, aCol, b, bCol, c, cCol, d, dCol ) {
  this.tri1 = new Triangle( a, aCol, b, bCol, c, cCol );
  this.tri2 = new Triangle( a, aCol, c, cCol, d, dCol );
  
  this.render = function() {
    this.tri1.render();
	this.tri2.render();
  }
}

// Create the object to represent a triangle
function Triangle (a, aCol, b, bCol, c, cCol) {
    // Build the vertices and colors manually by creating arrays
    this.vertices = [
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ];
    this.colors = [
      aCol[0], aCol[1], aCol[2],
      bCol[0], bCol[1], bCol[2],
      cCol[0], cCol[1], cCol[2]
    ];

  // The function that actually adds the triangle geometry to the scene
  this.render = function() {
    var geometry = new THREE.BufferGeometry();
    // Set the "position" attribute accordingly
    // Note: itemSize = 3 (second argument) because there are 3 values (components) per vertex
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3 ) );
    geometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array(this.colors), 3 ) );
    // Indicate that the material's vertexColors are based on the color attribute of vertexes
    var material = new THREE.MeshBasicMaterial( { vertexColors: true } );
    this.mesh= new THREE.Mesh( geometry, material );
    scene.add(this.mesh);
  }	
}

function puzzleShapes(){
  let shapes = [];
    
    // Create 10 shapes (random rectangles and triangles)
    for(let i = 0; i < 6; i++) {
        let randX = getRandom(-0.5, 0.5);
        let randY = getRandom(-0.5, 0.5);
        
        // Create rectangle shapes as pairs of triangles
        let square = new Square(
            [randX, randY, 0], [Math.random(), 0, 0], 
            [randX + 0.1, randY, 0], [0, Math.random(), 0], 
            [randX + 0.1, randY + 0.1, 0], [0, 0, Math.random()], 
            [randX, randY + 0.1, 0], [Math.random(), Math.random(), 0]
        );
        shapes.push(square);
    }
    
    // Create random triangles
    for(let i = 0; i < 4; i++) {
        let randX = getRandom(-0.5, 0.5);
        let randY = getRandom(-0.5, 0.5);
        
        let triangle = new Triangle(
            [randX, randY, 0], [Math.random(), 0, 0],
            [randX + 0.1, randY, 0], [0, Math.random(), 0], 
            [randX, randY + 0.1, 0], [0, 0, Math.random()]
        );
        shapes.push(triangle);
    }
    
    // Render the shapes
    shapes.forEach(shape => shape.render());


}

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 3;  // Try moving this around!
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);

//creates a red octagon to be the canvas of the puzzle
var octagon = new Canvas([0.14, .3, 0],[1,0,0],[.3, 0.14, 0],[1,0,0],[ .3, -0.14, 0],[1,0,0],[0.14, -.3, 0],[1,0,0],[-0.14, -.3, 0],[1,0,0],[-.3, -0.14, 0],[1,0,0],[-.3, 0.14, 0],[1,0,0],[-0.14, .3, 0],[1,0,0]);
octagon.render();

puzzleShapes();


// 10 hardcoded triangular pieces (basis for location, dimensions/shape fo can be changed)
var piece1 = new Triangle([0.3,0.3,0], [1,0,0], [0.5,0.3,0], [1,0,0], [0.5,0.5,0], [1,0,0]);
piece1.render();

var piece2 = new Triangle([-0.3,-0.3,0], [1,0,0], [-0.5,-0.3,0], [1,0,0], [-0.5,-0.5,0], [1,0,0]);
piece2.render();

var piece3 = new Triangle([0.5,-0.5,0], [1,0,0], [0.7,-0.5,0], [1,0,0], [0.7,-0.3,0], [1,0,0]);
piece3.render();

var piece4 = new Triangle([0.4,0,0], [1,0,0], [0.6,0,0], [1,0,0], [0.6,0.2,0], [1,0,0]);
piece4.render();

var piece5 = new Triangle([-0.3,0.6,0], [1,0,0], [-0.3,0.4,0], [1,0,0], [-0.1,0.4,0], [1,0,0]);
piece5.render();

var piece6 = new Triangle([-0.5,0.5,0], [1,0,0], [-0.5,0.3,0], [1,0,0], [-0.3,0.3,0], [1,0,0]);
piece6.render();

var piece7 = new Triangle([0,0.4,0], [1,0,0], [0.2,0.6,0], [1,0,0], [0,0.6,0], [1,0,0]);
piece7.render();

var piece8 = new Triangle([0,-0.4,0], [1,0,0], [0,-0.6,0], [1,0,0], [0.2,-0.6,0], [1,0,0]);
piece8.render();

var piece9 = new Triangle([-0.1,-0.7,0], [1,0,0], [-0.3,-0.7,0], [1,0,0], [-0.3,-0.9,0], [1,0,0]);
piece9.render();

var piece10 = new Triangle([-0.5,0,0], [1,0,0], [-0.5,0.2,0], [1,0,0], [-0.7,0,0], [1,0,0]);
piece10.render();

// Essentially, this creates the "Frames-per-second" loop
function animate() {
  requestAnimationFrame( animate );
  render();
}

// This is a wrapper function (needed for the requestAnimationFrame call above) for render
function render(){
  renderer.render( scene, camera );
}

// Initiate the graphical loop
animate();
var globalTranslateToggle = 0.3;

document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>