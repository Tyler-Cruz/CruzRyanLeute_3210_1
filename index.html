<!DOCTYPE html>
<html>
<head>
    <title>CruzRyanLeute Puzzle</title>
</head>
<body>

    <canvas id="myCanvas" width="1200" height="800"></canvas>

    <script type="module">
import * as THREE from 'three';
import { DragControls } from 'three/examples/jsm/controls/DragControls.js';

//random positions
function getRandom(min, max){
  return Math.random() * (max - min) + min;
}

//creates a canvas in the shape of an octagon
function Canvas(a, aCol, b, bCol, c, cCol, d, dCol, e, eCol, f, fCol, g, gCol, h, hCol, i, iCol, j, jCol, k, kCol, l, lCol, m, mCol, n, nCol, o, oCol, p, pCol){
    //makes triangles to form the shape of an octagon
    this.tri1 = new Triangle(a, aCol, d, dCol, e, eCol);
    this.tri2 = new Triangle(a, aCol, e, eCol, b, bCol);
    this.tri3 = new Triangle(b, bCol, e, eCol, f, fCol);
    this.tri4 = new Triangle(b, bCol, f, fCol, c, cCol);
    this.tri5 = new Triangle(c, cCol, f, fCol, g, gCol);
    this.tri6 = new Triangle(c, cCol, g, gCol, h, hCol);
    this.tri7 = new Triangle(d, dCol, i, iCol, e, eCol);
    this.tri8 = new Triangle(e, eCol, i, iCol, j, jCol);
    this.tri9 = new Triangle(e, eCol, j, jCol, f, fCol);
    this.tri10 = new Triangle(f, fCol, j, jCol, k, kCol);
    this.tri11 = new Triangle(f, fCol, k, kCol, g, gCol);
    this.tri12 = new Triangle(g, gCol, k, kCol, l, lCol);
    this.tri13 = new Triangle(g, gCol, l, lCol, h, hCol);
    this.tri14 = new Triangle(h, hCol, l, lCol, m, mCol);
    this.tri15 = new Triangle(i, iCol, n, nCol, j, jCol);
    this.tri16 = new Triangle(j, jCol, n, nCol, k, kCol);
    this.tri17 = new Triangle(k, kCol, n, nCol, o, oCol);
    this.tri18 = new Triangle(k, kCol, o, oCol, l, lCol);
    this.tri19 = new Triangle(l, lCol, o, oCol, p, pCol);
    this.tri20 = new Triangle(l, lCol, p, pCol, m, mCol);
    


    this.render = function(){
        this.tri1.render();
        this.tri2.render();
        this.tri3.render();
        this.tri4.render();
        this.tri5.render();
        this.tri6.render();
        this.tri7.render();
        this.tri8.render();
        this.tri9.render();
        this.tri10.render();
        this.tri11.render();
        this.tri12.render();
        this.tri13.render();
        this.tri14.render();
        this.tri15.render();
        this.tri16.render();
        this.tri17.render();
        this.tri18.render();
        this.tri19.render();
        this.tri20.render();

    }
}

// An object to produce a Square
function Square( a, aCol, b, bCol, c, cCol, d, dCol ) {
  this.tri1 = new pieceTriangle( a, aCol, b, bCol, c, cCol );
  this.tri2 = new pieceTriangle( a, aCol, c, cCol, d, dCol );
  
  this.render = function() {
    this.tri1.render();
	this.tri2.render();
  }
}

// Create the object to represent a triangle
function Triangle (a, aCol, b, bCol, c, cCol) {
    // Build the vertices and colors manually by creating arrays
    this.vertices = [
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ];
    this.colors = [
      aCol[0], aCol[1], aCol[2],
      bCol[0], bCol[1], bCol[2],
      cCol[0], cCol[1], cCol[2]
    ];

  // The function that actually adds the triangle geometry to the scene
  this.render = function() {
    var geometry = new THREE.BufferGeometry();
    // Set the "position" attribute accordingly
    // Note: itemSize = 3 (second argument) because there are 3 values (components) per vertex
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3 ) );
    geometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array(this.colors), 3 ) );
    // Indicate that the material's vertexColors are based on the color attribute of vertexes
    var material = new THREE.MeshBasicMaterial( { vertexColors: true } );
    this.mesh= new THREE.Mesh( geometry, material );
    scene.add(this.mesh);

  }	
}
// specific triangle function definition so that only puzzle pieces can be dragged
function pieceTriangle (a, aCol, b, bCol, c, cCol) {
    // Build the vertices and colors manually by creating arrays
    this.vertices = [
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ];
    this.colors = [
      aCol[0], aCol[1], aCol[2],
      bCol[0], bCol[1], bCol[2],
      cCol[0], cCol[1], cCol[2]
    ];

  // The function that actually adds the triangle geometry to the scene
  this.render = function() {
    var geometry = new THREE.BufferGeometry();
    // Set the "position" attribute accordingly
    // Note: itemSize = 3 (second argument) because there are 3 values (components) per vertex
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(this.vertices), 3 ) );
    geometry.setAttribute( 'color', new THREE.BufferAttribute( new Float32Array(this.colors), 3 ) );
    // Indicate that the material's vertexColors are based on the color attribute of vertexes
    var material = new THREE.MeshBasicMaterial( { vertexColors: true } );
    this.mesh= new THREE.Mesh( geometry, material );
    scene.add(this.mesh);

    //add mesh to drag list
    draggableObjects.push(this.mesh);

  }	
}

  function puzzleShapes(){
  let shapes = [];

  
    
    // Create 10 shapes (random rectangles and triangles)
    for(let i = 0; i < 6; i++) {
        let randX = getRandom(-0.3, 0.3);
        let randY = getRandom(-0.3, 0.3);
        
        // Create rectangle shapes as pairs of triangles
        let square = new Square(
            [randX, randY, 0], [Math.random(), 0, 0], 
            [randX + 0.25, randY, 0], [0, Math.random(), 0], 
            [randX + 0.25, randY + 0.25, 0], [0, 0, Math.random()], 
            [randX, randY + 0.25, 0], [Math.random(), Math.random(), 0]
        );
        shapes.push(square);
    }
    
    // Create random triangles
    for(let i = 0; i < 4; i++) {
        let randX = getRandom(-0.5, 0.5);
        let randY = getRandom(-0.5, 0.5);
        
        let triangle = new pieceTriangle(
            [randX, randY, 0], [Math.random(), 0, 0],
            [randX + 0.25, randY, 0], [0, Math.random(), 0], 
            [randX, randY + 0.25, 0], [0, 0, Math.random()]
        );
        shapes.push(triangle);
    }
    
    // Render the shapes
    shapes.forEach(shape => shape.render());


}


var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 3;  // Try moving this around!
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0));
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);

// Array for objects to drag
var draggableObjects = [];

//creates a red octagon to be the canvas of the puzzle
var octagon = new Canvas([-.25,.5,0],[1,0,0],[0,.5,0],[1,0,0],[.25,.5,0],[1,0,0],[-.5,.25,0],[1,0,0],[-.25,.25,0],[1,0,0],
[0,.25,0],[1,0,0],[.25,.25,0],[1,0,0],[.5,.25,0],[1,0,0],[-.5,-.25,0],[1,0,0],[-.25,-.25,0],[1,0,0],
[0,-.25,0],[1,0,0],[.25,-.25,0],[1,0,0],[.5,-.25,0],[1,0,0],[-.25,-.5,0],[1,0,0],[0,-.5,0],[1,0,0],
[.25,-.5,0],[1,0,0]);

octagon.render();

// // 10 hardcoded triangular pieces (basis for location, dimensions/shape fo can be changed)
// var piece1 = new pieceTriangle([0.3,0.3,0], [1,0,0], [0.5,0.3,0], [1,0,0], [0.5,0.5,0], [1,0,0]);
// piece1.render();
// var piece2 = new pieceTriangle([-0.3,-0.3,0], [1,0,0], [-0.5,-0.3,0], [1,0,0], [-0.5,-0.5,0], [1,0,0]);
// piece2.render();
// var piece3 = new pieceTriangle([0.5,-0.5,0], [1,0,0], [0.7,-0.5,0], [1,0,0], [0.7,-0.3,0], [1,0,0]);
// piece3.render();
// var piece4 = new pieceTriangle([0.4,0,0], [1,0,0], [0.6,0,0], [1,0,0], [0.6,0.2,0], [1,0,0]);
// piece4.render();
// var piece5 = new pieceTriangle([-0.3,0.6,0], [1,0,0], [-0.3,0.4,0], [1,0,0], [-0.1,0.4,0], [1,0,0]);
// piece5.render();
// var piece6 = new pieceTriangle([-0.5,0.5,0], [1,0,0], [-0.5,0.3,0], [1,0,0], [-0.3,0.3,0], [1,0,0]);
// piece6.render();
// var piece7 = new pieceTriangle([0,0.4,0], [1,0,0], [0.2,0.6,0], [1,0,0], [0,0.6,0], [1,0,0]);
// piece7.render();
// var piece8 = new pieceTriangle([0,-0.4,0], [1,0,0], [0,-0.6,0], [1,0,0], [0.2,-0.6,0], [1,0,0]);
// piece8.render();
// var piece9 = new pieceTriangle([-0.1,-0.7,0], [1,0,0], [-0.3,-0.7,0], [1,0,0], [-0.3,-0.9,0], [1,0,0]);
// piece9.render();
// var piece10 = new pieceTriangle([-0.5,0,0], [1,0,0], [-0.5,0.2,0], [1,0,0], [-0.7,0,0], [1,0,0]);
// piece10.render();

puzzleShapes();

//Drag setup
var controls = new DragControls(draggableObjects, camera, renderer.domElement);

// event listeners for drag control events
controls.addEventListener('dragstart', function (event) {
    event.object.material.opacity = 0.5;
});

controls.addEventListener('dragend', function (event) {
    event.object.material.opacity = 1; 
});

//Something New: Audio
//loads the downloaded song in from the files
let bMusic = new Audio('elevator-music-kevin-macleod-background-music-hd-128-ytshorts.savetube.me.mp3');
//autoplays the sound from the background
bMusic.play();

// Essentially, this creates the "Frames-per-second" loop
function animate() {
  requestAnimationFrame( animate );
  render();
}

// This is a wrapper function (needed for the requestAnimationFrame call above) for render
function render(){
  renderer.render( scene, camera );
}

// Initiate the graphical loop
animate();
var globalTranslateToggle = 0.3;

document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>